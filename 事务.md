# 事务

## 数据库事务概念

事务就是一组原子性的SQL查询，或者说一个独立的工作单元。如果数据库引擎能够成功地对数据库应用该组查询的全部语句，那么就执行该组查询。如果其中有任何一条语句因为奔溃或其他原因无法执行，那么所有的语句都不会执行。也就是事务内的语句要么全部执行成功，要么全部失败。

## 事务具备的特性

### 原子性(atomicity)

一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性。

### 一致性(consistency)

数据库总是从一个一致性的状态转换到另外一个一致性的状态。事务的执行过程中不允许违反设定的约束。参照链接:
链接：https://www.zhihu.com/question/31346392/answer/569142076

### 隔离性(isolation)

通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。在前面的例子中，当执行完第三条语句、第四条语句还未开始时，此时有另外一个账户汇总程序开始运行，则其看到的支票账户的余额并没有被减去200美元。后面我们讨论隔离级别(Isolation level)的时候,会发现为什么我们要说“通常来说”是不可见的。

### 持久性(durabilityy)

一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。持久性是个有点模糊的概念，因为实际上持久性也分很多不同的级别。有些持久性策略能够提供非常强的安全保障，而有些则未必。而且不可能有能做到100%的持久性保证的策略（如果数据库本身就能做到真正的持久性，那么备份又怎么能增加持久性呢?)。在后面的一些章节中，我们会继续讨论MySQL中持久性的真正含义。

## 分布式CAP理论

CAP理论是由加州大学Eric Brewer教授提出来的，这个理论告诉我们，一个分布式系统不可能同时满足一致性(Consistency)、可用性(Availability)、分区容错性(Partition tolerance)这三个基本需求，最多只能同时满足其中两项。
  **一致性**：这里的一致性是指数据的强一致，也称为线性一致性。是指在分布式环境中，数据在多个副本之间是否能够保持一致的特性。也就是说对某个数据进行写操作后立马执行读操作，必须能读取到刚刚写入的值。
  **可用性**：任意被无故障节点接收到的请求，必须能够在有限的时间内响应结果。
  **分区容错性**：如果集群中的机器被分成了两部分，这两部分不能互相通信，系统是否能继续正常工作。

## 分布式事务解决方法

### 两阶段提交

两阶段提交（Two-phase Commit，2PC），通过引入协调者来协调参与者的行为，并最终决定这些参与者是否要真正执行事务。二阶段分别指的是准备（投票）和提交两个阶段。

在XA分布式事务的第一阶段，作为事务协调者的节点会首先向所有的参与者节点发送Prepare请求。在接到Prepare请求之后，每一个参与者节点会各自执行与事务有关的数据更新，写入Undo Log和Redo Log。如果参与者执行成功，暂时不提交事务，而是向事务协调节点返回“完成”消息。当事务协调者接到了所有参与者的返回消息，整个分布式事务将会进入第二阶段。

![p](E:\DistCode\TyporaLoad\事务.assets\p.png)

在XA分布式事务的第二阶段，如果事务协调节点在之前所收到都是正向返回，那么它将会向所有事务参与者发出Commit请求。接到Commit请求之后，事务参与者节点会各自进行本地的事务提交，并释放锁资源。当本地事务完成提交后，将会向事务协调者返回“完成”消息。当事务协调者接收到所有事务参与者的“完成”反馈，整个分布式事务完成。

![p](E:\DistCode\TyporaLoad\事务.assets\p-1604025112130.png)

失败处理流程，在XA的第一阶段，如果某个事务参与者反馈失败消息，说明该节点的本地事务执行不成功，必须回滚。于是在第二阶段，事务协调节点向所有的事务参与者发送Abort请求。接收到Abort请求之后，各个事务参与者节点需要在本地进行事务的回滚操作，回滚操作依照Undo Log来进行。2PC 是一个**同步阻塞协议**，在一阶段协调者有超时机制，如果准备阶段未收到全部参与者的确认消息将回滚。在二阶段提交阶段失败的话参与者只能不断重试

### 存在的问题(2PC)

1.性能问题

XA协议遵循强一致性。在事务执行过程中，各个节点占用着数据库资源，只有当所有节点准备完毕，事务协调者才会通知提交，参与者提交后释放资源。这样的过程有着非常明显的性能问题。

2.协调者单点故障问题

事务协调者是整个XA模型的核心，一旦事务协调者节点挂掉，参与者收不到提交或是回滚通知，参与者会一直处于中间状态无法完成事务。

3.丢失消息导致的不一致问题

在XA协议的第二个阶段，如果发生局部网络问题，一部分事务参与者收到了提交消息，另一部分事务参与者没收到提交消息，那么就导致了节点之间数据的不一致。

### 三阶段提交(3PC)

三阶段提交（3PC），3PC 的出现是为了解决 2PC 的一些问题，相比于 2PC 它在**参与者中也引入了超时机制**，并且**新增了一个阶段**使得参与者可以利用这一个阶段统一各自的状态。3PC 包含了三个阶段，分别是 准备阶段、预提交阶段和提交阶段。

### TCC

TCC，2PC 和 3PC 都是数据库层面的，而 TCC 是业务层面的分布式事务，TCC 指的是`Try - Confirm - Cancel`。

- Try 指的是预留，即资源的预留和锁定，**注意是预留**。
- Confirm 指的是确认操作，这一步其实就是真正的执行了。
- Cancel 指的是撤销操作，可以理解为把预留阶段的动作撤销了。

举个例子，假入 Bob 要向 Smith 转账，思路大概是： 我们有一个本地方法，里面依次调用

1. 首先在 Try 阶段，要先调用远程接口把 Smith 和 Bob 的钱给冻结起来。
2. 在 Confirm 阶段，执行远程调用的转账的操作，转账成功进行解冻。
3. 如果第2步执行成功，那么转账成功，如果第二步执行失败，则调用远程冻结接口对应的解冻方法 (Cancel)。

TCC属于应用层的一种补偿方式，所以需要在实现的时候多写很多补偿的代码，对于每一个操作你都需要定义三个动作分别对应`Try - Confirm - Cancel`。因此 **TCC 对业务的侵入较大和业务紧耦合**，需要根据特定的场景和业务逻辑来设计相应的操作。还有一点要注意，撤销和确认操作的执行可能需要重试，因此还需要保证**操作的幂等**。

### 本地消息表

本地消息表其实就是利用了 **各系统本地的事务**来实现分布式事务。本地消息表顾名思义就是会有一张存放本地消息的表，一般都是放在数据库中，然后在执行业务的时候 **将业务的执行和将消息放入消息表中的操作放在同一个事务中**，这样就能保证消息放入本地表中业务肯定是执行成功的。

然后再去调用下一个操作，如果下一个操作调用成功了，消息表的消息状态可以直接改成已成功。

如果调用失败也没事，会有**后台任务定时去读取本地消息表**，筛选出还未成功的消息再调用对应的服务，服务更新成功了再变更消息的状态。

![915a02484990dda820410c8cad2389c5386](E:\DistCode\TyporaLoad\事务.assets\915a02484990dda820410c8cad2389c5386.webp)

这时候有可能消息对应的操作不成功，因此也需要重试，重试就得保证对应服务的方法是幂等的，而且一般重试会有最大次数，超过最大次数可以记录下报警让人工处理。

可以看到本地消息表其实实现的是**最终一致性**，容忍了数据暂时不一致的情况。

### 消息事务

参照RocketMQ事务.





## 参考资料

* 《高性能Mysql》
* 分布式概念  https://zhuanlan.zhihu.com/p/181161035
* 什么是分布式事务  https://blog.csdn.net/bjweimengshu/article/details/79607522
* 分布式事务六种解决方案  https://zhuanlan.zhihu.com/p/183753774
* 分布式事务的四种解决方案  https://www.cnblogs.com/mayundalao/p/11798502.html
